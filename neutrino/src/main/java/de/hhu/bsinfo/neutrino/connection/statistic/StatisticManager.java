package de.hhu.bsinfo.neutrino.connection.statistic;

import org.jctools.maps.NonBlockingHashMapLong;
import java.util.concurrent.atomic.AtomicLong;


/**
 * Statistic manager to keep track of different statistics from connection management.
 *
 * @author Christian Gesse
 */
public class StatisticManager {
    /**
     * ID provider for execute latency statistics (other statistics do already have ids)
     */
    public final AtomicLong executeIdProvider = new AtomicLong(1);

    /**
     * Map for work request statistics using the remote local id as key
     */
    private final NonBlockingHashMapLong<RequestStatistic> requestStatisticMap = new NonBlockingHashMapLong<>();
    /**
     * Map for latencies of connection process using the connection id as key
     */
    private final NonBlockingHashMapLong<LatencyStatistic> connectLatencyStatisticMap = new NonBlockingHashMapLong<>();
    /**
     * Map for latency before posting RDMA work requests with artificial ids as keys
     */
    private final NonBlockingHashMapLong<LatencyStatistic> executeLatencyStatisticMap = new NonBlockingHashMapLong<>();

    /**
     * Register remote node in work request map
     *
     * @param remoteLocalId the local id of the remote node
     */
    public void registerRemote(short remoteLocalId) {
        requestStatisticMap.putIfAbsent(remoteLocalId, new RequestStatistic(remoteLocalId));
    }

    /**
     * Start connect latency measurement
     *
     * @param id        the id of the connection
     * @param startTime the start time of the connection process in ns
     */
    public void startConnectLatencyStatistic(long id, long startTime) {

        var statistic = new LatencyStatistic();
        statistic.id = id;
        statistic.startTime = startTime;

        connectLatencyStatisticMap.putIfAbsent(id, statistic);
    }

    /**
     * End connect latency measurement.
     *
     * @param id      the id of the connection
     * @param endTime the end time of the connection process in ns
     */
    public void endConnectLatencyStatistic(long id, long endTime) {
       connectLatencyStatisticMap.get(id).endTime = endTime;
    }

    /**
     * Start execute latency measurement
     *
     * @param id        the id generated by the id provider
     * @param startTime the start time of the execute operation
     */
    public void startExecuteLatencyStatistic(long id, long startTime) {

        var statistic = new LatencyStatistic();
        statistic.id = id;
        statistic.startTime = startTime;

        executeLatencyStatisticMap.putIfAbsent(id, statistic);
    }

    /**
     * End execute latency measurement
     *
     * @param id      the id generated by the id provider
     * @param endTime the end time right before posting the work request in ns
     */
    public void endExecuteLatencyStatistic(long id, long endTime) {
        executeLatencyStatisticMap.get(id).endTime = endTime;
    }

    /**
     * Put send event into work request map
     *
     * @param remoteLocalId the local id of the remote node
     * @param bytesSend     the bytes send in this work request
     */
    public void putSendEvent(short remoteLocalId, long bytesSend) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.bytesSent.addAndGet(bytesSend);
            statistic.sendCount.incrementAndGet();
        }
    }

    /**
     * Put receive event into work request map
     *
     * @param remoteLocalId the local id of the remote node
     * @param bytesReceived the bytes received in this work request
     */
    public void putReceiveEvent(short remoteLocalId, long bytesReceived) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.bytesReceived.addAndGet(bytesReceived);
            statistic.receiveCount.incrementAndGet();
        }
    }

    /**
     * Put rdma write event into work request map
     *
     * @param remoteLocalId the local id of the remote node
     * @param bytesWritten  the bytes written in rdma operation
     */
    public void putRDMAWriteEvent(short remoteLocalId, long bytesWritten) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.rdmaBytesWritten.addAndGet(bytesWritten);
            statistic.rdmaWriteCount.incrementAndGet();
        }
    }

    /**
     * Put rdma read event into work request map
     *
     * @param remoteLocalId the local id of the remote node
     * @param bytesRead     the bytes read in rdma operation
     */
    public void putRDMAReadEvent(short remoteLocalId, long bytesRead) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.rdmaBytesRead.addAndGet(bytesRead);
            statistic.rdmaReadCount.incrementAndGet();
        }
    }

    /**
     * Put other op event (that does not fit into previous categories) into work request map
     *
     * @param remoteLocalId the local id of the remote node
     */
    public void putOtherOpEvent(short remoteLocalId) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.otherOpCount.incrementAndGet();
        }
    }

    /**
     * Put error event into work request map
     *
     * @param remoteLocalId the local id of the remote node
     */
    public void putErrorEvent(short remoteLocalId) {
        var statistic = requestStatisticMap.get(remoteLocalId);

        if(statistic != null) {
            statistic.errorCount.incrementAndGet();
        }
    }

    /**
     * Get the total rdma bytes written on all remote nodes
     *
     * @return the total rdma bytes written
     */
    public long getTotalRDMABytesWritten() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.rdmaBytesWritten.get();
        }

        return ret;
    }

    /**
     * Get the total rdma bytes read from all remote nodes
     *
     * @return the total rdma bytes read
     */
    public long getTotalRDMABytesRead() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.rdmaBytesRead.get();
        }

        return ret;
    }

    /**
     * Get the total bytes sent to all remote nodes
     *
     * @return the total bytes sent
     */
    public long getTotalBytesSent() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.bytesSent.get();
        }

        return ret;
    }

    /**
     * Get the total bytes received from all remote nodes
     *
     * @return the total bytes received
     */
    public long getTotalBytesReceived() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.bytesReceived.get();
        }

        return ret;
    }

    /**
     * Get the count of all sent work requests to remote nodes
     *
     * @return the total send count
     */
    public long getTotalSendCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.sendCount.get();
        }

        return ret;
    }

    /**
     * Get the count of all received work requests from remote nodes
     *
     * @return the total receive count
     */
    public long getTotalReceiveCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.receiveCount.get();
        }

        return ret;
    }

    /**
     * Get the count of all rdma write operations on remote nodes
     *
     * @return the total rdma write count
     */
    public long getTotalRDMAWriteCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.rdmaWriteCount.get();
        }

        return ret;
    }

    /**
     * Get the count of all rdma read operations on remote nodes
     *
     * @return the total rdma read count
     */
    public long getTotalRDMAReadCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.rdmaReadCount.get();
        }

        return ret;
    }

    /**
     * Get the count of all other operations that do not fit into the previous categories
     *
     * @return the total other op count
     */
    public long getTotalOtherOpCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.otherOpCount.get();
        }

        return ret;
    }

    /**
     * Get the count of all work requests completed with error status.
     *
     * @return the total error count
     */
    public long getTotalErrorCount() {
        long ret = 0;

        for(var statistic : requestStatisticMap.values()) {
            ret += statistic.errorCount.get();
        }

        return ret;
    }

    /**
     * Get array of all registered connect latencies
     *
     * @return array of all connect latencies
     */
    public long[] getConnectLatencies() {
        var data = connectLatencyStatisticMap.values();
        long[] latencies = new long[data.size()];

        int idx = 0;

        for(var statistic : data) {
            latencies[idx] = statistic.endTime - statistic.startTime;

            idx++;
        }

        return latencies;
    }

    /**
     * Get array of all registered execute latencies
     *
     * @return the long [ ]
     */
    public long[] getExecuteLatencies() {
        var data = executeLatencyStatisticMap.values();
        long[] latencies = new long[data.size()];

        int idx = 0;

        for(var statistic : data) {
            latencies[idx] = statistic.endTime - statistic.startTime;

            idx++;
        }

        return latencies;
    }

}
